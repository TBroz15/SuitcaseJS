// This code is minified and originated from @std/jsonc by the Deno authors licensed with the MIT License
// https://github.com/denoland/std/tree/main/jsonc

export function parse(s){if(new.target)throw new TypeError("Cannot create an instance: parse is not a constructor");return new u(s).parse()}class u{#i=new Set(` 	\r
    `);#a=new Set([..."[]{}:,/",...this.#i]);#e;#t;#n;constructor(e){this.#e=`${e}`,this.#t=this.#e.length,this.#n=this.#u()}parse(){const e=this.#r(),r=this.#s(e),{done:t,value:i}=this.#n.next();if(!t)throw new SyntaxError(n(i));return r}#r(){const{done:e,value:r}=this.#n.next();if(e)throw new SyntaxError("Cannot parse JSONC: unexpected end of JSONC input");return r}*#u(){for(let e=0;e<this.#t;e++)if(!this.#i.has(this.#e[e])){if(this.#e[e]==="/"&&this.#e[e+1]==="*"){e+=2;let r=!1;for(;e<this.#t;e++)if(this.#e[e]==="*"&&this.#e[e+1]==="/"){r=!0;break}if(!r)throw new SyntaxError("Cannot parse JSONC: unexpected end of JSONC input");e++;continue}if(this.#e[e]==="/"&&this.#e[e+1]==="/"){for(e+=2;e<this.#t&&!(this.#e[e]===`
    `||this.#e[e]==="\r");e++);continue}switch(this.#e[e]){case"{":yield{type:"BeginObject",position:e};break;case"}":yield{type:"EndObject",position:e};break;case"[":yield{type:"BeginArray",position:e};break;case"]":yield{type:"EndArray",position:e};break;case":":yield{type:"NameSeparator",position:e};break;case",":yield{type:"ValueSeparator",position:e};break;case'"':{const r=e;let t=!1;for(e++;e<this.#t&&!(this.#e[e]==='"'&&!t);e++)t=this.#e[e]==="\\"&&!t;yield{type:"String",sourceText:this.#e.substring(r,e+1),position:r};break}default:{const r=e;for(;e<this.#t&&!this.#a.has(this.#e[e]);e++);e--,yield{type:"NullOrTrueOrFalseOrNumber",sourceText:this.#e.substring(r,e+1),position:r}}}}}#s(e){switch(e.type){case"BeginObject":return this.#c();case"BeginArray":return this.#l();case"NullOrTrueOrFalseOrNumber":return this.#p(e);case"String":return this.#o(e);default:throw new SyntaxError(n(e))}}#c(){const e={};for(;;){const r=this.#r();if(r.type==="EndObject")return e;if(r.type!=="String")throw new SyntaxError(n(r));const t=this.#o(r),i=this.#r();if(i.type!=="NameSeparator")throw new SyntaxError(n(i));const a=this.#r();Object.defineProperty(e,t,{value:this.#s(a),writable:!0,enumerable:!0,configurable:!0});const o=this.#r();if(o.type==="EndObject")return e;if(o.type!=="ValueSeparator")throw new SyntaxError(n(o))}}#l(){const e=[];for(;;){const r=this.#r();if(r.type==="EndArray")return e;e.push(this.#s(r));const t=this.#r();if(t.type==="EndArray")return e;if(t.type!=="ValueSeparator")throw new SyntaxError(n(t))}}#o(e){let r;try{r=JSON.parse(e.sourceText)}catch{throw new SyntaxError(n(e))}if(typeof r!="string")throw new TypeError(`Parsed value is not a string: ${r}`);return r}#p(e){if(e.sourceText==="null")return null;if(e.sourceText==="true")return!0;if(e.sourceText==="false")return!1;let r;try{r=JSON.parse(e.sourceText)}catch{throw new SyntaxError(n(e))}if(typeof r!="number")throw new TypeError(`Parsed value is not a number: ${r}`);return r}}function n({type:s,sourceText:e,position:r}){let t="";switch(s){case"BeginObject":t="{";break;case"EndObject":t="}";break;case"BeginArray":t="[";break;case"EndArray":t="]";break;case"NameSeparator":t=":";break;case"ValueSeparator":t=",";break;case"NullOrTrueOrFalseOrNumber":case"String":t=30<e.length?`${e.slice(0,30)}...`:e;break}return`Cannot parse JSONC: unexpected token "${t}" in JSONC at position ${r}`}
    